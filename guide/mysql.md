## 三范式

第一范式：要求有主键，并且要求每一个字段原子性不可再分
  第二范式：要求所有非主键字段完全依赖主键，不能产生部分依赖，有联合主键a、b，字段c依赖于b。
  第三范式：所有非主键字段和主键字段之间不能产生传递依赖。字段c依赖于b，b依赖于a 

## Mysql 存储引擎

### MyISAM

5.5版本之前的默认引擎
  不支持行锁，支持表锁
  不支持事务
  不支持外键
  不支持崩溃后的安全恢复
  支持全文索引

### InnoDB

5.5版本后的默认引擎
  支持事务
  支持行锁
  支持外键
  支持崩溃后的安全恢复
  支持全文索引

一般情况下我们选择 InnoDB 都是没有问题的，除了需要读密集的情况，不介意崩溃恢复问题

事务隔离级别

1. 读未提交：可以读取其他事务未提交的修改
  2. 读提交：事务提交修改后才能被其他事务看见
  3. 可重复读：读取数据时，不允许修改。
  4. 串行化：只有一个事务提交后才会执行另一个事务

## 索引

### **定义**：

索引是一种用于快速查询和检索数据的数据结构。

### **使用索引的优点**：

可以大大加快数据的检索速度（大大减少检索的数据量），通过唯一索引，可以保证数据库表中每一行数据的唯一性。

**使用索引的缺点**：

1. 创建索引和维护索引需要耗费许多时间：当对表中的数据进行增删改时，如果有索引，那么索引也需要动态的修改，会降低sql的执行效率。
2. 占用物理存储空间：索引需要一定的物理文件存储，也会耗费一定的空间。

### **建索引的几大原则**

1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 

### **索引种类**

#### **从物理存储角度**

1、聚集索引（clustered index）

2、非聚集索引（non-clustered index）

#### **从逻辑角度**

1、主键索引：要求关键字唯一且不为null

2、普通索引：对关键字没有限制

3、组合索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合

4、唯一索引：关键字不能重复

#### **索引优化**

- 应尽量避免在     where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
              select id from t where num is null

          可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
          select id from t where num=0
          
- 应尽量避免在     where     子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。
  应尽量避免在     where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
              select id from t where num=10 or num=20

  可以这样查询：
   select id from t where num=10
   union all
   select id from t where num=20

- 对应同一列进行 or 判断时，使用 in 代替 or

- in     的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。
  对于连续的数值，能用     between 就不要用 in 了：
              select id from t where num between 1 and 3
- 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法利用索引。
              见如下例子：
              SELECT * FROM T1 WHERE NAME LIKE ‘%L%’
              SELECT * FROM T1 WHERE SUBSTING(NAME,2,1)=’L’
              SELECT * FROM T1 WHERE NAME LIKE ‘L%’

          即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作
          
- 应尽量避免在     where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
- 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
- 不要在     where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引  

## Sql join 的几种情况

  ![image-20200518111858987](..\img\image-20200518111858987.png)

 

## MySQL 主从复制原理的是啥？

主库将变更写入 binlog 日志，然后从库连接到主库之后，从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，写入一个 relay 中继日志中。接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

 

半同步复制，用来解决主库数据丢失问题

这个所谓半同步复制，也叫semi-sync复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。

并行复制，用来解决主从同步延时问题。

所谓并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。

### **大表优化**

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：

#### **1.** **限定数据的范围**

务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；

#### **2.** **读/**写分离

经典的数据库拆分方案，主库负责写，从库负责读；

#### **3.** **垂直分区**

**根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

**简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。 

![数据库垂直分区](..\img\数据库垂直分区.jpeg)

**垂直拆分的优点：**      可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
  **垂直拆分的缺点：**      主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

#### **4.** **水平分区**

**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。** 

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

![数据库水平拆分](..\img\数据库水平拆分.jpeg)

水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 

 

## **一些可能常用的**sql

#### 在student_course表查询课程1成绩第2高的学生，如果第2高的不止一个则列出所有的学生 

select * from student_course
 where cid=1 and score = (
 select score from student_course where cid = 1 group by score order by score desc limit 1,1
 );

#### 各科最高

select sid,cid,max(score) from student_course group by cid; 

### 每组的前N条纪录 

select * from student_course x where
 2>(select count(distinct(score)) from student_course y where y.cid=x.cid and y.score>x.score)
 order by cid,score desc; 

#### 指定时间段登录次数大于N次

SELECT create_by FROM (SELECT distinct create_by , DATE_FORMAT(create_date , '%Y-%m-%d') day FROM sys_log WHERE create_date > '2019-05-07 16:07:53' and create_date < '2019-05-15 16:07:53' ) a  GROUP BY a.create_by HAVING COUNT(*) > 3;

 

 

 

 

 