# 1、导读

### 1.1 如何评价代码质量

可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性

其中，**可维护性、可读性、可扩展性**又是提到最多的、最重要的三个评价标准

> 面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等

# 2、面向对象

面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

面向对象编程从字面上，按照最简单、最原始的方式来理解，就是将对象或类作为代码组织的基本单元，来进行编程的一种编程范式或者编程风格。

**面向对象分析**就是要搞清楚做什么，**面向对象设计**就是要搞清楚怎么做，**面向对象编程**就是将分析和设计的的结果翻译成代码的过程

### 封装

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据，达到隐藏信息和保护数据的目的。

它需要编程语言提供权限访问控制语法来支持，例如 Java 中的 private、protected、public 关键字。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

```java
private String name;
public String getName(){return this.name;}
```

### 抽象

隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。

```java
public interface Animal{
    public void say();
}
public class Cat implements Animal{
    public void say(){System.out.print("fuck")}
}
```

通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。

抽象作为一种只关注功能点不关注实现的设计思路，帮我们过滤非必要的实现细节。

### 继承

继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。

```java
public class Animal{
    public void say(){//...};
}
public class Cat extends Animal{
    public void say(){System.out.print("fuck")}
}
```

继承最大的好处是代码复用。

### 多态

多态是指，子类可以替换父类，实现方式：

- 父类引用子类对象 `Animal a = new Cat()`
- 支持继承 `extends`
- 子类重新父类方法 `Override`
- 接口类实现 `implements`

多态特性能提高代码的可扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

# 3、面向过程

面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。

面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

# 4、设计原则

SOLID :单一职责原则、开闭原则、里氏替换原则、接口隔离原则、依赖反转原则

### 4.1 单一职责原则

> 一个类或者模块只负责完成一个职责（或者功能）

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。

我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。

### 4.2 开闭原则

> 对扩展开放，修改关闭。

这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。

### 4.3里氏替换

一、如何理解里氏替换原则？
1.子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。
2.里氏替换原则更有指导意义的描述是：按照协议来设计。子类在设计的时候，要遵守父类的行为约定/协议。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；注释中所罗列的特殊说明。同理也可以对应到接口和实现类。

二、哪些代码明显违背了LSP?
1.子类违背父类声明要实现的功能
父类中提供的sortOrdersByAmount()订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个方法之后是按照创建日期来给订单排序的。那子类的设计就违背里氏替换原则。
2.子类违背父类对输入、输出、异常的约定
父类中某个函数约定：运行出错返回null；获取数据为空时返回空集合。子类重写函数之后，运行出错返回异常，获取不到数据返回null。那子类的设计就违背里氏替换原则。
父类中某个函数约定，输入数据可以是任意整数，子类实现只允许输入数据是正整数，负数就抛出，也就是说子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里氏替换原则。
父类中某个函数约定，只会抛出ArgumentNullException异常，子类的设计实现抛出了其他的异常，那子类的设计就违背了里氏替换原则。
3.子类违背父类注释中所罗列的任何特殊说明
父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。
4.判断子类的设计实现是否违背里氏替换原则，我们可以拿父类的单元测试去验证子类的代码。如果某些单元测试运行事呗，就有可能说明子类的设计实现没有完全遵守父类的约定，子类就有可能违背了里氏替换原则。

三、多态和里氏替换原则的区别
多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。

里式替换是细力度的开闭原则。这个准则应用的场景，往往是在方法功能的调整上，要达到的效果是：该方法对已经调用的代码的效果不变，并能支撑新的功能或提供更好的性能。换句话说，就是在保证兼容的前提条件下做扩展和调整

### 4.4 接口隔离原则