

#### 方法的参数传递机制

- 形参是基本数据类型

  传递数据值

- 实参是引用类型数据

  传递地址值

  特殊类型：String、包装类等对象不可变性

  bigdecimal 的操作会new一个新对象

#### 简单的递归

爬楼梯，每次可以爬一阶或者二阶，对于n阶的楼梯，有多少种走法

```java
public int f(n){
    if(n<1){
        throw new Exception("不能小于1");
    }
    if(n==1|n=2){
        return n;
    }else{
        return f(n-1)+f(n-2);
    }
}
```

#### spring bean的作用域

可以通过scope属性来指定bean的作用域

- singleton：默认值，懂ioc容器已创建就会创建bean的实例，而且是单例的，每次得到都是同一个
- prototype：原型的，当ioc容器一创建不再实例化该bean，每次调用getBean方法时再实例化该bean
- request：每次请求实例化一个bean
- session:在一次会话中共享一个bean

#### spring的传播行为

####  springMVC如何解决post中文乱码问题，GET的又如何处理

- 通过CharaterEncodingFilter类处理

#### 简单谈一下springMVC的工作流程

- ![image-20200422110346285](.\img\image-20200422110346285.png)

#### redis持久化工作类型

- RDB: 在指定时间间隔内将内存的数据集快照写入磁盘中,，恢复时将快照文件直接读到内存中

  优点：节省磁盘，恢复速度快

  缺点：会丢失最后一次快照后的所有修改。数据量大的话会比较耗性能

- AOF：以日志的形式来记录每个写操作，将redis执行过的所有写指令记录下来，只许追加但不可以改写文件，redis启动时会读取该文件的内容，将写指令从前往后执行过一次以完成数据的恢复工作。

  优点：备份更稳健，丢失概率更低，

  缺点：占用更多磁盘，恢复备份速度要慢

  推荐每秒钟备份一次aof

#### mysql什么时候适合建索引，什么时候不适合建索引

**适合**：

- 频繁作为查询条件的
- 需要排序的
- 查询中统计或者分组的字段

**不适合**

- 记录太少
- 经常增删改 的字段
- where条件中用不到的
- 区分度不高的

#### GC发生在哪里？GC分几种？

- GC在堆中

- 年轻代minor GC   老年代 Major GC

- GC算法有四种

  引用计数法：每次被引用就＋1，清除没有引用的

  复制算法：内存分两块，将有引用的复制到to区域，清除from区，年轻代中使用

  标记清除：标记所有需要回收的对象，在标记完成后同意回收掉被标记的对象。

  标记压缩：使用标记清除后，将所有存活对象移至一端，清除边界以外的内存。
  
  分代回收：将内存划分为年轻代和老年代，分别使用复制算法和标记压缩算法。

#### redis在项目中的使用场景

**数据类型**

- string ：记录一个ip的登录次数，incrby
- hash： 存储各种信息
- list：记录最新消息的排行，push存，pop取
- set： 自动排重
- zset：权重排序

#### 消息队列在项目中的应用

背景：在高并发的环境下，来不及处理大量的请求数据，导致请求发生阻塞。比如大量的增删改请求到达数据库，导致无数的行锁。或者大量的日志。。。

- 异步处理
- 并行
- 排队按顺序处理

### spring 、springboot、 springcloud 

spring是一个生态系统，包含了springframework、springboot 、spring cloud、spring data等一系列

我们说的spring一般指的是springframework，是个轻量级控制反转和面向切面的容器。它有两个核心特性：ioc和aop，ioc是控制反转，很早以前的是手动创建实例对象，使用IOC后，是通过spring容器创建bean对象，我们直接获取就可以了。降低组件耦合，使各服务层解耦。另一个特点是aop，面向切面编程，将权限判断、日志、事务这些重复代码统一进行处理，可以实现专注于业务代码，减少重复劳动。

springMVC 是spring的一部分，MVC模式的web框架，主要包括了中心控制器，视图解析器，处理器映射器，处理器适配器，

springboot是一个整合各种配置的快速开发框架，单独使用spring时，它的理念是约定优于配置，将以前的各种手动配置都自动化封装了，提供默认的配置，非常容易上手，免去了配置过程中大量的版本冲突问题。

spring cloud是基于springboot的一系列框架集合，是用来做微服务的，包括了注册发现中心，配置中心，消息总线，网关、反向代理、限流、熔断、监控等一系列功能，实现了项目的高可用和解耦。

#### 常用的设计模式

- 工厂方法模式：

  创建一个定义对象的接口，由子类决定具体实现哪个工厂类。

  使用地点：静态方法来获取具体的数据库连接。

- 单例模式：

  构造方法私有化，对外提供获取对象的方法。保证一个类仅有一个实例，避免频繁的创建。

  例：数据库连接的创建

- 代理模式：

  代理模式就是多一个代理类出来，替原对象进行一些操作

  例：spring aop中使用了动态代理，可以对程序方法之前和之后进行日志处理、事务处理。

### sql优化

- 对常用的查询字段，比如时间、工厂id使用索引
- 避免大表的关联查询，尽量使用范围查询，对于字段比较多的表考虑进行拆分，对数据量超大的表进行分表分库
- 查询时避免索引失效，比如对字段进行null判断，!= 判断，字段进行表达式操作，字段上使用函数，like使用 “%”开头的搜索
- 使用执行计划，查看查询是不是命中了索引，避免全表搜索。
- 最左前缀匹配原则，将范围查询放后面。

### HashMap 原理

容量：数组的个数，也就是桶的个数，默认为16

负载因子：键值对个数/容量

HashMap在java1.7版本使用了数组+链表的结构，即数组中的元素就是链表，链表中存放了hash值、数据值、下一个链表节点，当put数据时，首先会对key值进行hash运算，获取到这个key在数组中的位置，然后通过遍历链表，一个个对应hash值，判断这个key值是否存在，如果存在，则替换key值，如果不存在，则添加到末尾。

随着hashmap中的值越来越多，hash碰撞也变多，对于超长的链表，需要通过遍历来查找对应的数据，效率会越来越低。在java1.8中，对hashmap有了优化，在链表长度大于8时，会将链表转化为红黑树(将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。