使用消息队列的优点

异步处理：提高系统吞吐量

应用解耦：系统间通过消息通信，不用关心其他系统的处理

流量削峰：缓解短时间内大量请求，减少高峰时期对服务器压力

日志处理：解决大量日志传输

消息通讯：内置了高效的通信机制



## 常见的问题

### 消息丢失

- 网络丢失：broker收到消息之后会给生产者一个确认响应（ack)，如果生产者没有收到正确的响应，会一直重试发送消息直到收到确认响应。
- 磁盘丢失：当broker将数据保存到磁盘后再发送确认响应
- 消费消息阶段：消费者处理完自身业务逻辑之后再给broker发送消费确认

### 消费重复

 消费成功后ack异常或者超时，broker会认为此消息未消费成功，进入重复消费。解决办法是在消费端保证幂等性（任意多次执行所产生的影响均与第一次执行的影响相同成为幂等操作），可以通过多条消息只消费第一条或者多条处理和处理一条造成的结果相同。

- 通过数据库的唯一键实现幂等：消息中的某个字段对应了数据库表中的唯一键，保存时将会报错。

- mysql提供了 如果主键不存在则插入，存在则更新的操作。

  ```sql 
  INSERT INTO test VALUES (1,'b4','c4') ON DUPLICATE KEY UPDATE b=VALUES(b),c=VALUES(c);
  ```

- 对每条消息加一个全局的id，消费时先去查一下这个id有没有被消费。消费后，写到Redis中。

### **消息积压**

消费者某个部分出现性能问题，来不及处理上游发送的消息，才导致消息积压

一定要保证消费端的消费性能要高于生产端的发送性能

处理办法：

优化消费业务逻辑，水平扩容，增加消费端的并发数来提升总体的消费性能。在扩容消费者实例数量时，必须同步扩容主体中的分区数，保证消费者的实例数和分区数是相等的。如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的。原因我们之前讲过，因为对于消费者来说，在每个分区上实际上只能支持单线程消费。

还可以单个消费者，收到消息后，不处理任何业务逻辑，将消息放到内存队列中就返回ack，然后启动多个业务线程处理。对于消费者宕机后内存队列中没有消费的数据丢失问题，可以在启动时，从当前偏移量-队列长度开始取数据。

我司的办法：由python脚本处理数据改为java处理，运行速度快上了10倍。



突然的消息积压：只有两种情况，发送快了，消费慢了

发送快了就需要提升消费能力，增加消费者，或者关闭一些不重要的业务，保证主业务正常

消费慢了：可能消费失败导致一条消息反复消费，或者业务卡在什么地方，触发死锁或者等待资源。



