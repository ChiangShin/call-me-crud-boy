https://tech.meituan.com/2018/11/15/java-lock.html 

## CAS算法

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。

CAS算法涉及到三个操作数：

- 需要读写的内存值 V。
- 进行比较的值 A。
- 要写入的新值 B。

当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。 

## **java锁** 

### 是否需要锁住同步资源

#### 	乐观锁：

​	认为使用数据期间，不会有其他线程修改，只是在更新数据时去判断其他线程是否进行了修改。如果没有修改，则更新数据，如	果有修改，则进行其他操作（报错或者重试）。通过无锁编程实现，比如CAS算法。

#### 	悲观锁：

​	认为使用数据期间，一定会有其他线程进行修改，因此获取数据时会先加锁。synchroized和各种lock。

​	乐观锁适合读多写少的场景，悲观锁适合读少写多的场景 

### 自旋锁、适应性自旋锁

 如果同步代码块非常简单，那么切换线程的时间有可能大于代码执行的时间。那么干脆让请求锁的线程一直请求，看看持有锁的线程是否很快释放锁。自旋锁等待的时间有一定的限制，如果自旋超过了限定次数（默认10次），就应当挂起线程。

自适应性自旋锁自旋的次数不固定，根据前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。 

### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁  

#### 公平锁、非公平锁

**公平锁**是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

**非公平锁**是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

#### 可重入锁 VS 非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。 

#### 独享锁 VS 共享锁 

独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。 