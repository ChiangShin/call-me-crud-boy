## 理解Spring中的IOC和AOP

- **IOC**   IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
- **AOP**:将那些与业务无关，将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

### 为什么需要AOP？

- AOP专门用于处理系统中分布于各个模块或者不同方法中的交叉关注点的问题。比如：在程序中，我们常常需要处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP是一种非常常用的解决方案。

- 面向切面编程对我们来说有什么好处？

- 1. 减少重复；
  2. 专注业务；

## Spring 中的 bean 的作用域有哪些?

- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
- prototype : 每次请求都会创建一个新的 bean 实例。
- request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
- session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。

## Spring事务

### 什么是事务？

- 事务是指逻辑上的一组操作，要么都执行，要么都不执行。

  事务的特性（ACID）：


- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保了动作要么全部完成，要么全部失败。

- 一致性：一旦事务完成，不管是失败还是成功，系统必须确保它所建模的业务处于一致的状态，而不是部分成功部分失败。在现实中的数据不应该被破坏。

- 隔离性：可能有很多事务同时处理相同的数据，因此每个事务都应该与其他的事务隔离开，防止数据损坏。

  并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；

- 持久性：一旦事务完成，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有影响。

### 	事务的配置方式

- 1. 编程式事务管理

- 编程式事务管理是侵入性事务管理，需要在代码中手动的启动事物，回滚事务，推荐使用TransactionTemplate。

- 1. 声明式事务

- 声明式事务管理是建立在AOP上的，其本质是对方法的前后拦截，然后在目标方法开始之前创建或加入一个事物，执行完目标方法之后根据执行的情况进行提交或回滚。

- 编程式事务每次实现都要单独实现，当业务量大功能复杂时，使用编程式事务无疑是痛苦的，而声明式事务不同，声明式事务属于无侵入式，不会影响业务逻辑的实现，只需要在配置文件中做相关的事务规则声明或者通过注解的方式，便可以将事务规则应用到业务逻辑中。

- 声明式事务有两种方式，一种是在配置文件（xml）中做相关的事务规则声明，另一种是基于@Transactional 注解的方式。

### 事务的传播行为

作用：解决业务层方法之间互相调用的事务问题

是指当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为 

- PROPAGATION_REQUIRED
        Spring默认的传播机制，能满足绝大部分业务需求，如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。如果外层没有事务，新建一个事务执行

- PROPAGATION_REQUIRES_NEW

     该事务传播机制是每次都会新开启一个事务，同时把外层事务挂起，当当前事务执行完毕，恢复上层事务的执行。如果外层没有事务，执行当前新开启的事务即可

- PROPAGATION_SUPPORT
         如果外层有事务，则加入外层事务，如果外层没有事务，则直接使用非事务方式执行。完全依赖外层的事务
- PROPAGATION_NOT_SUPPORT
         该传播机制不支持事务，如果外层存在事务则挂起，执行完当前代码，则恢复外层事务，无论是否异常都不会回滚当前的代码
- PROPAGATION_NEVER
         该传播机制不支持外层事务，即如果外层有事务就抛出异常
- PROPAGATION_MANDATORY
         与NEVER相反，如果外层没有事务，则抛出异常
- PROPAGATION_NESTED

     外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。该传播机制的特点是可以保存状态保存点，当前事务回滚到某一个点，从而避免所有的嵌套事务都回滚，即各自回滚各自的.

### 事务的隔离级别

隔离级别定义了一个事务可能受其他并发事务影响的程度。 

**并发事务引起的问题**：

1. 脏读（Dirty read）
             脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。
2. 不可重复读（Nonrepeatable     read）
             不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。

不可重复读重点在修改。

1. 幻读（Phantom reads）
                 幻读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。

幻读重点在新增或删除

| **隔离级别**               | **含义**                                                     |
| -------------------------- | ------------------------------------------------------------ |
| ISOLATION_DEFAULT          | 使用后端数据库默认的隔离级别                                 |
| ISOLATION_READ_UNCOMMITTED | 允许读取尚未提交的更改。可能导致脏读、幻读或不可重复读。     |
| ISOLATION_READ_COMMITTED   | （Oracle  默认级别）允许从已经提交的并发事务读取。可防止脏读，但幻读和不可重复读仍可能会发生。 |
| ISOLATION_REPEATABLE_READ  | （MYSQL默认级别）对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻读仍可能发生。 |
| ISOLATION_SERIALIZABLE     | 完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。 |

 

### 只读

如果一个事务只对数据库执行读操作，那么该数据库就可能利用那个事务的只读特性，采取某些优化措施。通过把一个事务声明为只读，可以给后端数据库一个机会来应用那些它认为合适的优化措施。 

### 事务超时

为了使一个应用程序很好地执行，它的事务不能运行太长时间。因此，声明式事务的下一个特性就是它的超时。

假设事务的运行时间变得格外的长，由于事务可能涉及对数据库的锁定，所以长时间运行的事务会不必要地占用数据库资源。这时就可以声明一个事务在特定秒数后自动回滚，不必等它自己结束。 

### 事物失效

- 数据库引擎不支持事务

  比如mysql的myISAM

- @transactional 加在private方法上

  @Transactional只能加在public方法上,如果需要在private方法中加入事务,可以使用Aspect配transactionManager使用

- 方法自调用

  目标类直接调用该类的其他标注了@Transactional 的方法（相当于调用了this.对象方法），事务不会起作用。事务不起作用其根本原因就是未通过代理调用，因为事务是在代理中处理的，没通过代理，也就不会有事务的处理。

- 没有被spring管理

- 不支持事务  事务级别  not_support

- try catch 掉了异常，没有throw 出来

- 异常类型错误

  ```java
  @Service
  public class UserServiceImpl implements UserService {
  
      @Transactional
      public void update(User user) {
      try{
  
      }catch(Exception e){
         log.error(e.getMessage(),e);
         throw new Exception(e.getMessage());
      }
      }
  
  }
  ```

  以上方式`throw new Exception(e.getMessage());`事务也是无效的,主要原因是**事务回滚的条件是throw 运行时异常(RunTimeException)**.如果需要其他异常也回滚,需要在@Transactional后面加上`rollbackFor`或者`noRollbackForClassName`来指明触发回滚的异常

- 没有配置事务管理器

### 回滚规则

事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）

但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。 

  /**
   \* 1.添加事务注解
   \* 使用propagation 指定事务的传播行为，即当前的事务方法被另外一个事务方法调用时如何使用事务。
   \* 默认取值为REQUIRED，即使用调用方法的事务
   \* REQUIRES_NEW：使用自己的事务，调用的事务方法的事务被挂起。
   *
   \* 2.使用isolation 指定事务的隔离级别，最常用的取值为READ_COMMITTED
   \* 3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。通常情况下，默认值即可。
   \* 4.使用readOnly 指定事务是否为只读。 表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。若真的是一个只读取数据库值得方法，应设置readOnly=true
   \* 5.使用timeOut 指定强制回滚之前事务可以占用的时间。
   */
 @Transactional(propagation=Propagation.REQUIRES_NEW,
       isolation=Isolation.READ_COMMITTED,
       noRollbackFor={UserAccountException.class},

​      rollbackFor=RuntimeException.class,
​       readOnly=true, timeout=3)
   @Override
   public void purchase(String username, String isbn) {
​       //doSomething.....
   }

##  **spring**、**springMVC**、**springboot**、 **springcloud** 的区别

spring是一个生态系统，包含了springframework、springboot 、spring cloud、spring data等一系列

我们说的spring一般指的是springframeworke，是个轻量级控制反转和面向切面的容器。它有两个核心特性：ioc和aop，ioc是控制反转，很早以前的是手动创建实例对象，使用IOC后，是通过spring容器创建bean对象，我们直接获取就可以了。降低组件耦合，使各服务层解耦。另一个特点是aop，面向切面编程，将权限判断、日志、事务这些重复代码统一进行处理，可以实现专注于业务代码，减少重复劳动。

springMVC 是spring的一部分，MVC模式的web框架，主要包括了中心控制器，视图解析器，处理器映射器，处理器适配器，

springboot是一个整合各种配置的快速开发框架，单独使用spring时，它的理念是约定优于配置，将以前的各种手动配置都自动化封装了，提供默认的配置，非常容易上手，免去了配置过程中大量的版本冲突问题。

spring cloud是基于springboot的一系列框架集合，包括了注册发现中心，配置中心，消息总线，网关，实现了反向代理、限流、熔断、监控等一系列功能，实现了项目的高可用和解耦。

## spring使用了哪些设计模式

**工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。

**代理设计模式** : Spring AOP 功能的实现。

**单例设计模式** : Spring 中的 Bean 默认都是单例的。

**模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。

**包装器设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

**观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。

**适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`

