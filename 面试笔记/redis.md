# 内存淘汰机制

    Redis提供了下面几种淘汰策略
    
    volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
    
    volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
    
    volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
    
    allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
    
    allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
    
    noeviction：禁止驱逐数据，当内存使用达到阈值的时候，所有引起申请内存的命令会报错 

# Redis 持久化

### RDB持久化

​	RDB持久化是通过**快照**的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。在创建快照之后，用户可以备份该快	照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。RDB是Redis默认的持久化方式

### AOF持久化

​	AOF持久化会把被执行的写命令写到AOF文件的末尾，记录数据的变化。

# 缓存雪崩

什么是缓存雪崩？

缓存同一时间大面积的失效，后面的请求都落到数据库上，造成数据库短时间内承受大量的请求而崩掉。

解决办法：

可以给缓存设置过期时间时加上一个随机值时间，使得每个key的过期时间分布开来，不会集中在同一时刻失效

（1）事前：**Redis** 高可用，主从+哨兵，**Redis cluster**，避免全盘崩溃。

（2）事中：本地 **ehcache** 缓存 + **Hystrix** 限流+降级，避免**MySQL**被打死。

（3）事后：**Redis** 持久化 **RDB**+**AOF**，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。 

# 缓存穿透 

### **什么是缓存穿透？**

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 

发起大量请求，导致大量请求落到数据库。

### **有哪些解决办法？**

最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等

**1**）缓存无效**key** **,**将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒 

**2**）布隆过滤器，判断**key**是否在数据库中存在

3）网关配置，拦截不正常访问的ip

 

### **缓存击穿**

至于**缓存击穿**，它跟**缓存雪崩**有点像，但也有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是，**缓存击穿**是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

解决办法：

采用分布式锁，只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有